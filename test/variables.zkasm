VAR GLOBAL myGlobalVar

start:        

        3141592     :MSTORE(myGlobalVar)
        
        1 => B
        0 => C,D

        ${mem.myGlobalVar} => A
        3141592 :ARITH

        ${ctx.globalHash} => A
        ${getGlobalHash()} :ARITH

        ${input.sequencerAddr} => A
        ${getSequencerAddr()} :ARITH

        ${input.chainId} => A
        ${getChainId()} :ARITH

        ${input.batchHashData} => A
        ${getBatchHashData()} :ARITH

        ${input.oldStateRoot} => A
        ${getOldStateRoot()} :ARITH

        ${input.newStateRoot} => A
        ${getNewStateRoot()} :ARITH

        ${(input.batchL2Data.length - 2)/2} => A
        ${getTxsLen()} :ARITH

        ${input.oldLocalExitRoot} => A
        ${getOldLocalExitRoot()} :ARITH

        ${input.globalExitRoot} => A
        ${getGlobalExitRoot()} :ARITH

        ${input.newLocalExitRoot} => A
        ${getNewLocalExitRoot()} :ARITH

        ${input.numBatch} => A
        ${getNumBatch()} :ARITH

        ${input.timestamp} => A
        ${getTimestamp()} :ARITH

opLT:

        ${rom.labels[global.codes[0x10]]} => A
        ${addrOp(0x10)} :ARITH

        0x10 => E

        ${rom.labels[global.codes[0x10]]} => A
        ${addrOp(0x10)} :ARITH

        :JMP(end)
       
end:
       0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR                 ; Set all registers to 0

longLoop:
        STEP-0x10000+40  : JMPC(longLoop2)
                        : JMP(finalLoop)
longLoop2:
        0
        0
        0
        0       ; 4
        0
        0
        0
        0       ; 8
        0
        0
        0
        0       ; 12
        0
        0
        0
        0       ; 16
        0
        0
        0
        0       ; 20
        0
        0
        0
        0       ; 24
        0
        0
        0
        0       ; 28
        0
        0
        0
        0       : JMP(longLoop) ; 32


finalLoop:
        STEP-0x10000+2  : JMPC(finalLoop)

                         : JMP(start)

opINVALID: